
  // relationship.relationshipValidate 
    /*  context.fieldsContainOwnerManyToMany = true;
     context.fieldsContainNoOwnerOneToOne = true;
     context.fieldsContainOwnerOneToOne = true;
     context.fieldsContainOneToMany = true;
     context.fieldsContainManyToOne = true;
     relationship.otherEntityModulePath 
     relationship.otherEntityModuleName
     relationship.otherEntityStateName =
     relationship.otherEntityFieldCapitalized
     relationship.otherentityClass = 'User';
     relationship.otherEntityTableName 
     relationship.otherEntityNameCapitalized
     relationship.otherEntityNamePlural
     relationship.otherEntityName */
    /* 
       const entityConfig = {
        jhipsterConfigDirectory: this.jhipsterConfigDirectory,
        filename: this.filename,
        data: this.data || this.fileData,
        useConfigurationFile: this.useConfigurationFile,
        fieldsContainOwnerManyToMany: this.fieldsContainOwnerManyToMany,
        fieldsContainNoOwnerOneToOne: this.fieldsContainNoOwnerOneToOne,
        fieldsContainOwnerOneToOne: this.fieldsContainOwnerOneToOne,
        fieldsContainOneToMany: this.fieldsContainOneToMany,
        fieldsContainInstant: this.fieldsContainInstant,
        fieldsContainZonedDateTime: this.fieldsContainZonedDateTime,
        fieldsContainLocalDate: this.fieldsContainLocalDate,
        fieldsContainBigDecimal: this.fieldsContainBigDecimal,
        fieldsContainBlob: this.fieldsContainBlob,
        fieldsContainImageBlob: this.fieldsContainImageBlob,
        jpaMetamodelFiltering: this.jpaMetamodelFiltering,
        pkType: this.pkType,
        entityApiUrl: this.entityApiUrl,
        entityClass: this.entityClass,
        entityTableName: this.entityTableName,
        entityInstance: this.entityInstance,
        entityFolderName: this.entityFolderName,
        entityFileName: this.entityFileName,
        entityServiceFileName: this.entityServiceFileName,
        entityStateName: this.entityStateName,
        entityUrl: this.entityUrl,
        entityTranslationKey: this.entityTranslationKey 
    };*/


  

/*   fields = [];
  field.fieldType;
  field.fieldName;
  field.fieldIsEnum
  field.fieldDescription

  fieldType === 'UUID'
  fieldType === 'Integer'
  fieldType === 'Instant'

  relationships = [];
  rela.relationshipType == 'many-to-one'
  rela.relationshipType == 'one-to-one' 
  rela.ownerSide == true 
  rela.relationshipType == 'many-to-many' 
  rela.relationshipName; 
  rela.otherEntityName */

/* 
  const nonEnumType = _.includes(['String', 'Integer', 'Long', 'Float', 'Double', 'BigDecimal',
  'LocalDate', 'Instant', 'ZonedDateTime', 'Boolean', 'byte[]', 'ByteBuffer'], fieldType);
 */

  context.pagination = 'no';
  context.validation = false;


  const entityName = context.name;
  const entityNamePluralizedAndSpinalCased = _.kebabCase(pluralize(entityName));

  context.entityClass = context.entityNameCapitalized;
  context.entityClassHumanized = _.startCase(context.entityNameCapitalized);
  context.entityClassPlural = pluralize(context.entityClass);
  context.entityClassPluralHumanized = _.startCase(context.entityClassPlural);
  context.entityInstance = _.lowerFirst(entityName);
  context.entityInstancePlural = pluralize(context.entityInstance);
  context.entityApiUrl = entityNamePluralizedAndSpinalCased;
  context.entityFileName = _.kebabCase(context.entityNameCapitalized + _.upperFirst(context.entityAngularJSSuffix));
  context.entityFolderName = context.entityFileName;
  context.entityPluralFileName = entityNamePluralizedAndSpinalCased + context.entityAngularJSSuffix;
  context.entityServiceFileName = context.entityFileName;

  context.entityClass = context.entityClass + _.upperFirst(_.camelCase(context.entityAngularJSSuffix));
  context.entityStateName = _.kebabCase(context.entityClass);
  context.entityUrl = context.entityStateName;
  context.entityTranslationKey = context.entityInstance;
  context.entityTranslationKeyMenu = _.camelCase(context.entityStateName);
  context.jhiTablePrefix = this.getTableName(context.jhiPrefix);

  context.fieldsContainInstant = false;
  context.fieldsContainZonedDateTime = false;
  context.fieldsContainLocalDate = false;
  context.fieldsContainBigDecimal = false;
  context.fieldsContainBlob = false;
  context.fieldsContainImageBlob = false;
  context.validation = false;
  context.fieldsContainOwnerManyToMany = false;
  context.fieldsContainNoOwnerOneToOne = false;
  context.fieldsContainOwnerOneToOne = false;
  context.fieldsContainOneToMany = false;
  context.fieldsContainManyToOne = false;
  context.differentTypes = [context.entityClass];
  if (!context.relationships) {
    context.relationships = [];
  }
  context.differentRelationships = {};

  // Load in-memory data for fields
  context.fields.forEach((field) => {
    // Migration from JodaTime to Java Time
    if (field.fieldType === 'DateTime' || field.fieldType === 'Date') {
      field.fieldType = 'Instant';
    }
    const fieldType = field.fieldType;

    const nonEnumType = _.includes(['String', 'Integer', 'Long', 'Float', 'Double', 'BigDecimal',
      'LocalDate', 'Instant', 'ZonedDateTime', 'Boolean', 'byte[]', 'ByteBuffer'], fieldType);
    if ((['sql', 'mongodb', 'couchbase'].includes(context.databaseType)) && !nonEnumType) {
      field.fieldIsEnum = true;
    } else {
      field.fieldIsEnum = false;
    }

    if (_.isUndefined(field.fieldNameCapitalized)) {
      field.fieldNameCapitalized = _.upperFirst(field.fieldName);
    }

    if (_.isUndefined(field.fieldNameUnderscored)) {
      field.fieldNameUnderscored = _.snakeCase(field.fieldName);
    }

    if (_.isUndefined(field.fieldNameAsDatabaseColumn)) {
      const fieldNameUnderscored = _.snakeCase(field.fieldName);
      const jhiFieldNamePrefix = this.getColumnName(context.jhiPrefix);
      if (jhiCore.isReservedTableName(fieldNameUnderscored, context.databaseType)) {
        field.fieldNameAsDatabaseColumn = `${jhiFieldNamePrefix}_${fieldNameUnderscored}`;
      } else {
        field.fieldNameAsDatabaseColumn = fieldNameUnderscored;
      }
    }

    if (_.isUndefined(field.fieldNameHumanized)) {
      field.fieldNameHumanized = _.startCase(field.fieldName);
    }

    if (_.isUndefined(field.fieldInJavaBeanMethod)) {
      // Handle the specific case when the second letter is capitalized
      // See http://stackoverflow.com/questions/2948083/naming-convention-for-getters-setters-in-java
      if (field.fieldName.length > 1) {
        const firstLetter = field.fieldName.charAt(0);
        const secondLetter = field.fieldName.charAt(1);
        if (firstLetter === firstLetter.toLowerCase() && secondLetter === secondLetter.toUpperCase()) {
          field.fieldInJavaBeanMethod = firstLetter.toLowerCase() + field.fieldName.slice(1);
        } else {
          field.fieldInJavaBeanMethod = _.upperFirst(field.fieldName);
        }
      } else {
        field.fieldInJavaBeanMethod = _.upperFirst(field.fieldName);
      }
    }

    if (_.isUndefined(field.fieldValidateRulesPatternJava)) {
      field.fieldValidateRulesPatternJava = field.fieldValidateRulesPattern
        ? field.fieldValidateRulesPattern.replace(/\\/g, '\\\\').replace(/"/g, '\\"') : field.fieldValidateRulesPattern;
    }

    if (_.isArray(field.fieldValidateRules) && field.fieldValidateRules.length >= 1) {
      field.fieldValidate = true;
    } else {
      field.fieldValidate = false;
    }

    if (fieldType === 'ZonedDateTime') {
      context.fieldsContainZonedDateTime = true;
    } else if (fieldType === 'Instant') {
      context.fieldsContainInstant = true;
    } else if (fieldType === 'LocalDate') {
      context.fieldsContainLocalDate = true;
    } else if (fieldType === 'BigDecimal') {
      context.fieldsContainBigDecimal = true;
    } else if (fieldType === 'byte[]' || fieldType === 'ByteBuffer') {
      context.fieldsContainBlob = true;
      if (field.fieldTypeBlobContent === 'image') {
        context.fieldsContainImageBlob = true;
      }
    }

    if (field.fieldValidate) {
      context.validation = true;
    }
  });
  // Load in-memory data for relationships
  context.relationships.forEach((relationship) => {
    if (_.isUndefined(relationship.relationshipNameCapitalized)) {
      relationship.relationshipNameCapitalized = _.upperFirst(relationship.relationshipName);
    }

    if (_.isUndefined(relationship.relationshipNameCapitalizedPlural)) {
      if (relationship.relationshipName.length > 1) {
        relationship.relationshipNameCapitalizedPlural = pluralize(_.upperFirst(relationship.relationshipName));
      } else {
        relationship.relationshipNameCapitalizedPlural = _.upperFirst(pluralize(relationship.relationshipName));
      }
    }

    if (_.isUndefined(relationship.relationshipNameHumanized)) {
      relationship.relationshipNameHumanized = _.startCase(relationship.relationshipName);
    }

    if (_.isUndefined(relationship.relationshipNamePlural)) {
      relationship.relationshipNamePlural = pluralize(relationship.relationshipName);
    }

    if (_.isUndefined(relationship.relationshipFieldName)) {
      relationship.relationshipFieldName = _.lowerFirst(relationship.relationshipName);
    }

    if (_.isUndefined(relationship.relationshipFieldNamePlural)) {
      relationship.relationshipFieldNamePlural = pluralize(_.lowerFirst(relationship.relationshipName));
    }

    if (_.isUndefined(relationship.otherEntityRelationshipNamePlural) && (relationship.relationshipType === 'one-to-many'
      || (relationship.relationshipType === 'many-to-many' && relationship.ownerSide === false)
      || (relationship.relationshipType === 'one-to-one' && relationship.otherEntityName.toLowerCase() !== 'user'))) {
      relationship.otherEntityRelationshipNamePlural = pluralize(relationship.otherEntityRelationshipName);
    }

    if (_.isUndefined(relationship.otherEntityRelationshipNameCapitalized)) {
      relationship.otherEntityRelationshipNameCapitalized = _.upperFirst(relationship.otherEntityRelationshipName);
    }

    if (_.isUndefined(relationship.otherEntityRelationshipNameCapitalizedPlural)) {
      relationship.otherEntityRelationshipNameCapitalizedPlural = pluralize(_.upperFirst(relationship.otherEntityRelationshipName));
    }

    const otherEntityName = relationship.otherEntityName;
    const otherEntityData = this.getEntityJson(otherEntityName);
    const jhiTablePrefix = context.jhiTablePrefix;

    if (context.dto && context.dto === 'mapstruct') {
      if (otherEntityData && (!otherEntityData.dto || otherEntityData.dto !== 'mapstruct')) {
        this.warning(chalk.red(`This entity has the DTO option, and it has a relationship with entity "${otherEntityName}" that doesn't have the DTO option. This will result in an error.`));
      }
    }

    if (otherEntityName === 'user') {
      relationship.otherEntityTableName = `${jhiTablePrefix}_user`;
    } else {
      relationship.otherEntityTableName = otherEntityData ? otherEntityData.entityTableName : null;
      if (!relationship.otherEntityTableName) {
        relationship.otherEntityTableName = this.getTableName(otherEntityName);
      }
      if (jhiCore.isReservedTableName(relationship.otherEntityTableName, context.prodDatabaseType)) {
        const otherEntityTableName = relationship.otherEntityTableName;
        relationship.otherEntityTableName = `${jhiTablePrefix}_${otherEntityTableName}`;
      }
    }

    if (_.isUndefined(relationship.otherEntityNamePlural)) {
      relationship.otherEntityNamePlural = pluralize(relationship.otherEntityName);
    }

    if (_.isUndefined(relationship.otherEntityNameCapitalized)) {
      relationship.otherEntityNameCapitalized = _.upperFirst(relationship.otherEntityName);
    }

    if (_.isUndefined(relationship.otherentityClass)) {
      if (relationship.otherEntityNameCapitalized !== 'User') {
        const otherEntityAngularSuffix = otherEntityData ? otherEntityData.angularJSSuffix || '' : '';
        relationship.otherentityClass = _.upperFirst(relationship.otherEntityName) + _.upperFirst(_.camelCase(otherEntityAngularSuffix));
      } else {
        relationship.otherentityClass = 'User';
      }
    }

    if (_.isUndefined(relationship.otherEntityNameCapitalizedPlural)) {
      relationship.otherEntityNameCapitalizedPlural = pluralize(_.upperFirst(relationship.otherEntityName));
    }

    if (_.isUndefined(relationship.otherEntityFieldCapitalized)) {
      relationship.otherEntityFieldCapitalized = _.upperFirst(relationship.otherEntityField);
    }

    if (_.isUndefined(relationship.otherEntityStateName)) {
      relationship.otherEntityStateName = _.kebabCase(relationship.otherentityClass);
    }
    if (_.isUndefined(relationship.otherEntityModuleName)) {
      if (relationship.otherEntityNameCapitalized !== 'User') {
        relationship.otherEntityModuleName = `${context.angularXAppName + relationship.otherEntityNameCapitalized}Module`;
        relationship.otherEntityModulePath = _.kebabCase(_.lowerFirst(relationship.otherEntityName));
      } else {
        relationship.otherEntityModuleName = `${context.angularXAppName}SharedModule`;
        relationship.otherEntityModulePath = '../shared';
      }
    }
    // Load in-memory data for root
    if (relationship.relationshipType === 'many-to-many' && relationship.ownerSide) {
      context.fieldsContainOwnerManyToMany = true;
    } else if (relationship.relationshipType === 'one-to-one' && !relationship.ownerSide) {
      context.fieldsContainNoOwnerOneToOne = true;
    } else if (relationship.relationshipType === 'one-to-one' && relationship.ownerSide) {
      context.fieldsContainOwnerOneToOne = true;
    } else if (relationship.relationshipType === 'one-to-many') {
      context.fieldsContainOneToMany = true;
    } else if (relationship.relationshipType === 'many-to-one') {
      context.fieldsContainManyToOne = true;
    }

    if (relationship.relationshipValidateRules && relationship.relationshipValidateRules.indexOf('required') !== -1) {
      relationship.relationshipValidate = relationship.relationshipRequired = context.validation = true;
    }

    const entityType = relationship.otherEntityNameCapitalized;
    if (context.differentTypes.indexOf(entityType) === -1) {
      context.differentTypes.push(entityType);
    }
    if (!context.differentRelationships[entityType]) {
      context.differentRelationships[entityType] = [];
    }
    context.differentRelationships[entityType].push(relationship);
  });

  context.pkType = this.getPkType(context.databaseType);
}

/*
{
  openapi: '3.0.2',
  info: {
    title: 'Swagger Petstore - OpenAPI 3.0',
    description: 'This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\n' +
      "Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\n" +
      "You can now help us improve the API whether it's by making changes to the definition itself or to the code.\n" +
      'That way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n' +
      '\n' +
      'Some useful links:\n' +
      '- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n' +
      '- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)',
    termsOfService: 'http://swagger.io/terms/',
    contact: { email: 'apiteam@swagger.io' },
    license: {
      name: 'Apache 2.0',
      url: 'http://www.apache.org/licenses/LICENSE-2.0.html'
    },
    version: '1.0.6'
  },
  externalDocs: {
    description: 'Find out more about Swagger',
    url: 'http://swagger.io'
  },
  servers: [ { url: '/api/v3' } ],
  tags: [
    {
      name: 'pet',
      description: 'Everything about your Pets',
      externalDocs: { description: 'Find out more', url: 'http://swagger.io' }
    },
    { name: 'store', description: 'Operations about user' },
    {
      name: 'user',
      description: 'Access to Petstore orders',
      externalDocs: {
        description: 'Find out more about our store',
        url: 'http://swagger.io'
      }
    }
  ],
  paths: {
    '/pet': {
      put: {
        tags: [Array],
        summary: 'Update an existing pet',
        description: 'Update an existing pet by Id',
        operationId: 'updatePet',
        requestBody: [Object],
        responses: [Object],
        security: [Array]
      },
      post: {
        tags: [Array],
        summary: 'Add a new pet to the store',
        description: 'Add a new pet to the store',
        operationId: 'addPet',
        requestBody: [Object],
        responses: [Object],
        security: [Array]
      }
    },
    '/pet/findByStatus': {
      get: {
        tags: [Array],
        summary: 'Finds Pets by status',
        description: 'Multiple status values can be provided with comma separated strings',
        operationId: 'findPetsByStatus',
        parameters: [Array],
        responses: [Object],
        security: [Array]
      }
    },
    '/pet/findByTags': {
      get: {
        tags: [Array],
        summary: 'Finds Pets by tags',
        description: 'Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.',
        operationId: 'findPetsByTags',
        parameters: [Array],
        responses: [Object],
        security: [Array]
      }
    },
    '/pet/{petId}': {
      get: {
        tags: [Array],
        summary: 'Find pet by ID',
        description: 'Returns a single pet',
        operationId: 'getPetById',
        parameters: [Array],
        responses: [Object],
        security: [Array]
      },
      post: {
        tags: [Array],
        summary: 'Updates a pet in the store with form data',
        description: '',
        operationId: 'updatePetWithForm',
        parameters: [Array],
        responses: [Object],
        security: [Array]
      },
      delete: {
        tags: [Array],
        summary: 'Deletes a pet',
        description: '',
        operationId: 'deletePet',
        parameters: [Array],
        responses: [Object],
        security: [Array]
      }
    },
    '/pet/{petId}/uploadImage': {
      post: {
        tags: [Array],
        summary: 'uploads an image',
        description: '',
        operationId: 'uploadFile',
        parameters: [Array],
        requestBody: [Object],
        responses: [Object],
        security: [Array]
      }
    },
    '/store/inventory': {
      get: {
        tags: [Array],
        summary: 'Returns pet inventories by status',
        description: 'Returns a map of status codes to quantities',
        operationId: 'getInventory',
        responses: [Object],
        security: [Array]
      }
    },
    '/store/order': {
      post: {
        tags: [Array],
        summary: 'Place an order for a pet',
        description: 'Place a new order in the store',
        operationId: 'placeOrder',
        requestBody: [Object],
        responses: [Object]
      }
    },
    '/store/order/{orderId}': {
      get: {
        tags: [Array],
        summary: 'Find purchase order by ID',
        description: 'For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions',
        operationId: 'getOrderById',
        parameters: [Array],
        responses: [Object]
      },
      delete: {
        tags: [Array],
        summary: 'Delete purchase order by ID',
        description: 'For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors',
        operationId: 'deleteOrder',
        parameters: [Array],
        responses: [Object]
      }
    },
    '/user': {
      post: {
        tags: [Array],
        summary: 'Create user',
        description: 'This can only be done by the logged in user.',
        operationId: 'createUser',
        requestBody: [Object],
        responses: [Object]
      }
    },
    '/user/createWithList': {
      post: {
        tags: [Array],
        summary: 'Creates list of users with given input array',
        description: 'Creates list of users with given input array',
        operationId: 'createUsersWithListInput',
        requestBody: [Object],
        responses: [Object]
      }
    },
    '/user/login': {
      get: {
        tags: [Array],
        summary: 'Logs user into the system',
        description: '',
        operationId: 'loginUser',
        parameters: [Array],
        responses: [Object]
      }
    },
    '/user/logout': {
      get: {
        tags: [Array],
        summary: 'Logs out current logged in user session',
        description: '',
        operationId: 'logoutUser',
        parameters: [],
        responses: [Object]
      }
    },
    '/user/{username}': {
      get: {
        tags: [Array],
        summary: 'Get user by user name',
        description: '',
        operationId: 'getUserByName',
        parameters: [Array],
        responses: [Object]
      },
      put: {
        tags: [Array],
        summary: 'Update user',
        description: 'This can only be done by the logged in user.',
        operationId: 'updateUser',
        parameters: [Array],
        requestBody: [Object],
        responses: [Object]
      },
      delete: {
        tags: [Array],
        summary: 'Delete user',
        description: 'This can only be done by the logged in user.',
        operationId: 'deleteUser',
        parameters: [Array],
        responses: [Object]
      }
    }
  },
  components: {
    schemas: {
      Order: {
        type: 'object',
        properties: {
          id: [Object],
          petId: [Object],
          quantity: [Object],
          shipDate: [Object],
          status: [Object],
          complete: [Object]
        },
        xml: { name: 'order' }
      },
      Customer: {
        type: 'object',
        properties: { id: [Object], username: [Object], address: [Object] },
        xml: { name: 'customer' }
      },
      Address: {
        type: 'object',
        properties: {
          street: [Object],
          city: [Object],
          state: [Object],
          zip: [Object]
        },
        xml: { name: 'address' }
      },
      Category: {
        type: 'object',
        properties: { id: [Object], name: [Object] },
        xml: { name: 'category' }
      },
      User: {
        type: 'object',
        properties: {
          id: [Object],
          username: [Object],
          firstName: [Object],
          lastName: [Object],
          email: [Object],
          password: [Object],
          phone: [Object],
          userStatus: [Object]
        },
        xml: { name: 'user' }
      },
      Tag: {
        type: 'object',
        properties: { id: [Object], name: [Object] },
        xml: { name: 'tag' }
      },
      Pet: {
        required: [ 'name', 'photoUrls' ],
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64', example: 10 },
          name: { type: 'string', example: 'doggie' },
          category: {
            type: 'object',
            properties: { id: [Object], name: [Object] },
            xml: { name: 'category' }
          },
          photoUrls: {
            type: 'array',
            xml: { wrapped: true },
            items: { type: 'string', xml: [Object] }
          },
          tags: {
            type: 'array',
            xml: { wrapped: true },
            items: { type: 'object', properties: [Object], xml: [Object] }
          },
          status: {
            type: 'string',
            description: 'pet status in the store',
            enum: [ 'available', 'pending', 'sold' ]
          }
        },
        xml: { name: 'pet' }
      },
      ApiResponse: {
        type: 'object',
        properties: { code: [Object], type: [Object], message: [Object] },
        xml: { name: '##default' }
      }
    },
    requestBodies: {
      Pet: {
        description: 'Pet object that needs to be added to the store',
        content: {
          'application/json': {
            schema: {
              required: [Array],
              type: 'object',
              properties: [Object],
              xml: [Object]
            }
          },
          'application/xml': {
            schema: {
              required: [Array],
              type: 'object',
              properties: [Object],
              xml: [Object]
            }
          }
        }
      },
      UserArray: {
        description: 'List of user object',
        content: { 'application/json': [Object] }
      }
    },
    securitySchemes: { 
      petstore_auth: {
        type: 'oauth2',
        flows: {
          implicit: {
            authorizationUrl: 'https://petstore3.swagger.io/oauth/authorize',
            scopes: {
              'write:pets': 'modify pets in your account',
              'read:pets': 'read your pets'
            }
          }
        }
      }, 
      api_key: { 
        type: 'apiKey', 
        name: 'api_key', 
        in: 'header' 
      } 
    }
  }
}





/*

curl -X 'GET' \
  'https://petstore3.swagger.io/api/v3/pet/findByStatus?status=available' \
  -H 'accept: application/xml'

  <ArrayList>

  <item>
    <id>9688</id>
    <category>
      <id>1</id>
      <name>dog</name>
    </category>
    <name>Doggie</name>
    <photoUrls>
      <photoUrl>http://pet.photo.com/super_pet</photoUrl>
    </photoUrls>
    <tags>
      <tag>
        <id>-8697</id>
        <name>defaultTag</name>
      </tag>
    </tags>
    <status>available</status>
  </item>

  <item>
    <id>-6314</id>
    <category>
      <id>1</id>
      <name>Dogs</name>
    </category>
    <name>Chickens Flora Cain</name>
    <photoUrls>
      <photoUrl>string</photoUrl>
    </photoUrls>
    <tags>
      <tag>
        <id>250</id>
        <name>defaultTag</name>
      </tag>
    </tags>
    <status>available</status>
  </item>
  </ArrayList>


{
  openapi: '3.0.2',
  info: {
    title: 'Swagger Petstore - OpenAPI 3.0',
    description: 'This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\n' +
      "Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\n" +
      "You can now help us improve the API whether it's by making changes to the definition itself or to the code.\n" +
      'That way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n' +
      '\n' +
      'Some useful links:\n' +
      '- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n' +
      '- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)',
    termsOfService: 'http://swagger.io/terms/',
    contact: { email: 'apiteam@swagger.io' },
    license: {
      name: 'Apache 2.0',
      url: 'http://www.apache.org/licenses/LICENSE-2.0.html'
    },
    version: '1.0.6'
  },
  externalDocs: {
    description: 'Find out more about Swagger',
    url: 'http://swagger.io'
  },
  servers: [ { url: '/api/v3' } ],
  tags: [
    {
      name: 'pet',
      description: 'Everything about your Pets',
      externalDocs: [Object]
    },
    { name: 'store', description: 'Operations about user' },
    {
      name: 'user',
      description: 'Access to Petstore orders',
      externalDocs: [Object]
    }
  ],
  paths: {
    '/pet': { put: [Object], post: [Object] },
    '/pet/findByStatus': { get: [Object] },
    '/pet/findByTags': { get: [Object] },
    '/pet/{petId}': { get: [Object], post: [Object], delete: [Object] },
    '/pet/{petId}/uploadImage': { post: [Object] },
    '/store/inventory': { get: [Object] },
    '/store/order': { post: [Object] },
    '/store/order/{orderId}': { get: [Object], delete: [Object] },
    '/user': { post: [Object] },
    '/user/createWithList': { post: [Object] },
    '/user/login': { get: [Object] },
    '/user/logout': { get: [Object] },
    '/user/{username}': { get: [Object], put: [Object], delete: [Object] }
  },
  components: {
    schemas: {
      Order: [Object],
      Customer: [Object],
      Address: [Object],
      Category: [Object],
      User: [Object],
      Tag: [Object],
      Pet: [Object],
      ApiResponse: [Object]
    },
    requestBodies: { Pet: [Object], UserArray: [Object] },
    securitySchemes: { petstore_auth: [Object], api_key: [Object] }
  }
}
{
  post: {
    tags: [ 'pet' ],
    summary: 'uploads an image',
    description: '',
    operationId: 'uploadFile',
    parameters: [
        {
            name: 'petId',
            in: 'path',
            description: 'ID of pet to update',
            required: true,
            schema: { type: 'integer', format: 'int64' }
        },
        {
            name: 'additionalMetadata',
            in: 'query',
            description: 'Additional Metadata',
            required: false,
            schema: { type: 'string' }
        }
    ],
    requestBody: { content: [Object] },
    responses: { '200': [Object] },
    security: [ [Object] ]
  }
}

*/
